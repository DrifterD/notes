# mysql-learning
记录mysql日志

## 事物
事物标准特性：ACID
1. 原子性（atomicity）
2. 一致性（consistency）
3. 隔离性(isolation)
4. 持久性（durability）

### 隔离级别
隔离性又分为四种类型

* READ UNCOMMITTED(未提交读)
事物中修改的且没有提交的数据其他事物也可以读取，即脏读

* READ COMMITTED(提交读)
一个事物从喀什直到提交之前，所有做的任何修改对其他事物不可见，这个级别有时候会叫做**不可重复读取（nonrepeatable read）**，因为两次执行同样的查询，可能会得到不一样结果

* REPEATABLE READ(可重复读) 默认
理论上，可重复读无法解决幻读问题，但是在mysql中InnoDB和XtraDB通过多版本控制（MVCC multiversion concurrency control）解决幻读问题

* SERIALIAZBLE 最高级别隔离，读取 的每一行数据上都枷锁，避免幻读问题。但是可能导致超时和锁竞争
>注： 幻读：基于插入或者删除场景
不可重复读取：基于update场景

## 索引
索引不同类型有不同特性，主要有以下类型：

### b-tree
大部分索引结构，实际上多数引擎通过B+Tree实现，即每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点范围遍历。B-Tree 所有的值都是按照顺序存储
优点：
* 支持精确查询
* 最左查询
* 范围查询
* 只访问索引的查询，即"覆盖索引"
......

### 哈希索引
hash索引必须精确匹配才能有效
只有memory引擎支持哈希索引

优点：
数据存储紧凑，快

缺点：
* 只保存哈希值和行索引，不保存字段值
* 不能按照索引值顺序存储，不能用于排序
* 只支持等值比较查询
* 哈希冲突叫多的场景下维护代价较高
* 索引全部列内容哈希的值，所以无法部分索引匹配查询
* 只支持等值比较查询，包括=，in(),<=>


innoDB 是否也支持hash索引呢？？

### R-tree 空间索引
MyIsam 支持空间索引
Mysql GIS支持不完善

### 全文索引

### 高性能索引策略
#### 独立列索引
>独立列值在where条件时不是函数参数，也不是表达式一部分

#### 前缀索引和索引的选择性
索引字段列值太降低效率和浪费空间，可以限制索引列前缀长度，从而提高索引效率和降低磁盘空间：

限制：
1.前缀索引用于group by 和order by会导致索引无效，全表扫描
2.无法使用覆盖扫描

#### 多列索引
>在一个表中建立多个单列索引

在多个列上建立单独索引大部分情况下不能提高Mysql查询性能，5.0之后引入的索引合并（index merge）策略，可以将多列索引来定位指定行。
但是可能更多带来资源消耗。一般explain 中出现 index merge，需要关注下表结构和索引是否需要优化


#### 索引顺序

#### 聚簇索引
>聚簇索引不是一个单独是索引类型，而是一种数据存储方式。每个存储引擎不同聚簇索引可能不同

聚簇索引数据行实际存储在索引的叶子页，叶节点存储是索引值
Mysql不支选择哪个索引作为聚簇索引，InnoDB将通过主键作为聚簇索引
##### 优点
1. 可以减少磁盘I/O访问
2. 数据访问更快
3. 使用覆盖索引扫描的查询可以直接使用页节点的主键值

##### 缺点
1. ? 插入速度严重依赖插入顺序，按照主键顺序插入是加载数据到InnoDB表中速度最快的方式，但是如果不是按照主键顺序加载数据，
那么在加载完后最好使用OPTIMIZE TABLE 命令重新组织下表 
2. 更新聚簇索引代价很高，因为会强制InnoDB将每一个被更新的行移动端奥新的位置
3. ？基于聚簇索引的表在插入新行，或者**主键被更新导致需要移动行**的时候，可能面临"页分裂"的问题，当行的主键值要求必须将这一行插入到某个以满足页中时，存储引擎会将该页分裂成两个页来容纳该行，这就导致表会占用更多的磁盘空间
4. 可能会导致全表扫描变慢，尤其是**行比较稀疏**，或者**页分裂**导致数据存储不连续的时候
5. 二级索引（非聚簇索引）可能比想象的要更大，因为二级索引的叶子节点包含了引用行的主键列
6. 二级访问需要两次索引查询 

>注：如果没有聚簇索引，那么二级索引只需要一次索引查询吗？？ OPTIMIZE TABLE 命令

MyISAM 引擎和InnoDB引擎对于聚簇索引区别
MyISAM聚簇索引就是一个非空的名为Primary的索引，并且不同索引行分别存储

![InnoDBvsMyISAM索引表分布](resources\InnoDBvsMyISAM索引表分布.PNG)

##### InnoDB顺序插入数据
优点：
1. 降低I/O访问
2. 只有页满时才会页分裂操作。uuid作为主键会导致频繁页分裂
3. 数据碎片化降低

缺点：
1.  在高并发的时候顺序主键会带来资源竞争，并发插入数据可能导致间隙锁竞争。另一个热点可能会是AUTO_INCREMENT 锁机制需要修改i
**innodb_autoinc_lock_mode** 配置

#### 覆盖索引
>如果一个索引包含或者覆盖所需要查询的字段的值，那么称之为“覆盖索引”
在`explain` 中Extral列中有“using index”就是说嘛这个查询用到了覆盖索引

优点：
1. 查询结果集条目远小于数据行数量，覆盖索引可以减少数据访问量
2. 索引按照值顺序存储，提高I/O访问顺序
3. InnoDB聚簇索引，二级索引包含了列值，符合使用覆盖索引条件

#### 索引扫描排序
>索引扫描排序更优于其他排序方式
EXPLAIN 列中的type值是"index"说明是索引排序
索引扫描排序条件：
1. order by 子句必须符合InnoDB索引最左侧有效的规则
2. order by 子句必须包含索引的列，如果order by中既有索引列也有非索引列则无效
3. 当索引最左值是常量的时候可以忽略最左原则，从第二个开始索引依有效
4. 多表关联时，只有当Order by 子句引用的字段全部为第一个表时，才能用索引做排序(这里优化器可能会优化sql，导致应该是第一个表被
处理成第二个表)
5.  order by 在使用多列索引时排序顺序必须一致
6. where子句和order by 子句可以连接成多列索引效应，前提是where子句中索引列必须是常量查询，不能范围查询


#### 压缩索引

Mysql允许一个列建立多个索引，冗余索引部分场景下有效

注：建议使用Percona工具排查冗余索引

后续：同时使用order by 和limit 使用 的用法？

#### 索引和锁

>二级索引使用共享锁，主键索引使用排他锁


#### 维护索引和表

索引损坏的常用命令：
1. optimize table: 支持引擎：InnoDB,MyISAM, ARCHIVE；缺点：表级锁;[官方引用](https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html)
2. check table xxx
3. repair table (alter table xxx engine=xxx 即不做任何修改的alter命令来重建表)

###### 索引统计信息
>索引统计信息作为优化器参考重要信息，决定使用正确的索引的关键数据

###### 减少索引和数据碎片化
Mysql中存在三种形式数据碎片：
1. 行碎片：行数据存储在不同磁盘空间中，通过索引访问会导致性能下降
2. 行间碎片：逻辑上顺序的页在或者在磁盘上是不是顺序存储。对于全表扫描和聚簇索引扫描有影响
3. 剩余空间碎片：数据页有大量空余空间，导致读取不需要的数据

>MyISAM 以上三种都有肯能发生，但是InnoDB不会重选短小的行碎片。可以通过`OPTIMIZE TABLE`重新整理数据

#### 其他
1. in 在少量的内容时候对于索引最左原则有效，即多列索引最左列 用in在内容不多的情况下可以实现有效的最左侧索引
2.  避免多个范围条件查询。 mysql 无法使用范围列后面的其他索引列、，但是对于多个等值条件查询（in）没有这个限制


#### 特定类型查询优化

##### count
count 查询非空的行数，`count(*)` 会忽略列值内容并且获取所有行数。
`count(col)`则统计指定列且非空的数量
count也支持表达式使用例如:`count(col=1 or null)`







## 分区表
分区表是一个逻辑表，底层由多个物理表实现


### 限制
1. 在MyISAM引擎下操作会导致表级锁，甚至整个分区，但是innoDB不存在
2. innoDB 外键和分区存在不兼容,innoDB不支持多磁盘用于子分区
3. InnoDB 使用alter table .... optimize partition 是不能正常工作在分区表中
4. 所有分区表引擎必须一致且和主表引擎一致
5. 删除分区，该分区内所有数据全部被删除
6. 所有被用在分区上字段必须是该表所有唯一索引的一部分(主键也是唯一索引一种，如果存在多个唯一索引，取公共字段)
>All columns used in the partitioning expression for a partitioned table must be part of every unique key that the table may have.

7. 一个表中没有主键或者没有唯一索引，那么分区字段不做限制
8. 在没有主键和唯一索引下创建的分区，在后期添加主键或者唯一索引时是受限制
9. 复杂的分区表达式可能会带来性能风险，因为更新，插入和删除一行都会计算一次分区表达式
10. 一个表最多只能分1024个子表
